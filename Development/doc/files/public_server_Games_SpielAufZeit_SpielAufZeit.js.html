<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>public/server/Games/SpielAufZeit/SpielAufZeit.js - Muliplayer Tetris</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Muliplayer Tetris"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.9</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/controller.Auswahl.html">controller.Auswahl</a></li>
            
                <li><a href="../classes/controller.Chat.html">controller.Chat</a></li>
            
                <li><a href="../classes/controller.Controller.html">controller.Controller</a></li>
            
                <li><a href="../classes/display.AfterGame.html">display.AfterGame</a></li>
            
                <li><a href="../classes/display.Display.html">display.Display</a></li>
            
                <li><a href="../classes/display.Lounge.html">display.Lounge</a></li>
            
                <li><a href="../classes/display.MyAudio.html">display.MyAudio</a></li>
            
                <li><a href="../classes/display.Spieler.html">display.Spieler</a></li>
            
                <li><a href="../classes/global.API_SCHEMA.html">global.API_SCHEMA</a></li>
            
                <li><a href="../classes/global.BUTTON.html">global.BUTTON</a></li>
            
                <li><a href="../classes/global.BUTTONTYPE.html">global.BUTTONTYPE</a></li>
            
                <li><a href="../classes/global.CONFIG.html">global.CONFIG</a></li>
            
                <li><a href="../classes/global.GAME_EVENT.html">global.GAME_EVENT</a></li>
            
                <li><a href="../classes/global.LIST_EVENT.html">global.LIST_EVENT</a></li>
            
                <li><a href="../classes/global.pre_defs.html">global.pre_defs</a></li>
            
                <li><a href="../classes/global.Util.html">global.Util</a></li>
            
                <li><a href="../classes/server.Api.html">server.Api</a></li>
            
                <li><a href="../classes/server.Chat.html">server.Chat</a></li>
            
                <li><a href="../classes/server.CommandLine.html">server.CommandLine</a></li>
            
                <li><a href="../classes/server.Controller.html">server.Controller</a></li>
            
                <li><a href="../classes/server.Database.html">server.Database</a></li>
            
                <li><a href="../classes/server.Display.html">server.Display</a></li>
            
                <li><a href="../classes/server.Game.html">server.Game</a></li>
            
                <li><a href="../classes/server.games.AbstractGame.html">server.games.AbstractGame</a></li>
            
                <li><a href="../classes/server.games.SpielAufZeit.html">server.games.SpielAufZeit</a></li>
            
                <li><a href="../classes/server.games.SpielAufZeit.Block.html">server.games.SpielAufZeit.Block</a></li>
            
                <li><a href="../classes/server.games.SpielAufZeit.Blockelement.html">server.games.SpielAufZeit.Blockelement</a></li>
            
                <li><a href="../classes/server.games.SpielAufZeit.Spieler.html">server.games.SpielAufZeit.Spieler</a></li>
            
                <li><a href="../classes/server.Main.html">server.Main</a></li>
            
                <li><a href="../classes/server.Profil.html">server.Profil</a></li>
            
                <li><a href="../classes/server.Router.html">server.Router</a></li>
            
                <li><a href="../classes/server.RouterChache.html">server.RouterChache</a></li>
            
                <li><a href="../classes/server.Server.html">server.Server</a></li>
            
                <li><a href="../classes/server.SpielTyp.html">server.SpielTyp</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/controller.html">controller</a></li>
            
                <li><a href="../modules/display.html">display</a></li>
            
                <li><a href="../modules/global.html">global</a></li>
            
                <li><a href="../modules/server.html">server</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: public/server/Games/SpielAufZeit/SpielAufZeit.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x27;use strict&#x27;;

var CONFIG = require(&#x27;./../../../global/config.js&#x27;).CONFIG;
var BUTTON = require(&#x27;./../../../global/enum_controller_buttons.js&#x27;).BUTTON;
var BUTTONTYPE = require(&#x27;./../../../global/enum_controller_buttons.js&#x27;).BUTTONTYPE;

var AbstractGame = require(&#x27;../AbstractGame.js&#x27;).AbstractGame;
var Spieler = require(&#x27;./Spieler.js&#x27;).Spieler;
var Block = require(&#x27;./Block.js&#x27;).Block;

/**
 * @module server
 * @namespace server.games
 *
 * @class SpielAufZeit
 * @constructor
 * @extends AbstractGame
 *
 * @param {Game} game
 */
function SpielAufZeit(game){
	/**
	 * @property _game
	 * @type server.Game
	 * @private
	 */
	this._game = game;
	
	/**
	 * @property _spieler
	 * @type Array
	 * @default []
	 * @private
	 */
	this._spieler = [];
	
	/**
	 * @property _statistics
	 * @type JSON
	 * @default {...}
	 * @private
	 */
	 this._statistics = {};
	 this._statistics.spieler = {};
	
	/**
	 * @property _w
	 * @type Number
	 * @default CONFIG.Games.SpielAufZeit.W
	 * @private
	 */
	this._w = CONFIG.Games.SpielAufZeit.W;
	
	/**
	 * @property _h
	 * @type Number
	 * @default CONFIG.Games.SpielAufZeit.H
	 * @private
	 */
	this._h = CONFIG.Games.SpielAufZeit.H;
	
	/**
	 * @property _field
	 * @type Array
	 * @default []
	 * @private
	 */
	this._field = [];
	
	/**
	 * @property _deathTicker
	 * @type Number
	 * @default 0
	 * @private
	 */
	this._deathTicker = 0;
} 
SpielAufZeit.prototype = new AbstractGame(null);
SpielAufZeit.prototype.constructor = AbstractGame;

/**
 * @method getH
 *
 * @return {Number}
 */
SpielAufZeit.prototype.getH = function(){
	return this._h;
};

/**
 * @method getW
 *
 * @return {Number}
 */
SpielAufZeit.prototype.getW = function(){
	return this._w;	
};

/**
 * @method addMitspieler
 *
 * @param {server.Profil} profil
 * @param {Array} color
 */
SpielAufZeit.prototype.addMitspieler = function(profil, color){
	var controller = profil.getController();
	var spieler = new Spieler(this, controller);
	
	spieler.setCursor([10, 0]); //TODO richtige werte.. -&gt; in der INIT, hier raus
	spieler.setColor(color);
	this._spieler.push(spieler);
	
	//
	this._statistics.spieler[spieler.getId()] = {}
	this._statistics.spieler[spieler.getId()].punkte = 0;
	this._statistics.spieler[spieler.getId()].buttonAt = {};
	this._statistics.spieler[spieler.getId()].punkteAt = {};
	this._statistics.spieler[spieler.getId()].punkteAt[this._t()] = 0;
};

/**
 * @method _init_t
 * @private
 */
SpielAufZeit.prototype._init_t = function(){
	this._t_start = (new Date()).getTime();
};

/**
 * @method _t
 * @return {Date}
 * @private
 */
SpielAufZeit.prototype._t = function(){
	return (new Date()).getTime()-this._t_start;
};

/**
 * @method init
 */
SpielAufZeit.prototype.init = /*overwride*/ function(){ 
	var x, y, row, table, i;

	// init _field
	table = [];
	for(y = 0; y &lt; this._h; y++){
		row = [];
		for(x = 0; x &lt; this._w; x++){
			row.push(null);
		}
		table.push(row);
	}
	this._field = table;
	
	this._init_t();
	this._statistics.gameStarts = this._t(); // wow, das spiel startet bei 0 ms... respect... such info..
};

/**
  @method tick
  */
SpielAufZeit.prototype.tick = /*overwride*/ function(){
	
	var i, doesThing, j, spieler;
	
	doesThing = false;
	
	// nach dem tod eines Spieler, punkte jeden tack vermindern
	if((++this._deathTicker%60) == 0){
		for(i in this._spieler){
			spieler = this._spieler[i];
			if(!spieler.compute()) continue;
			if(spieler.isDeath()){
				spieler.addPunkte(-1); // -1 Punkt, beim setzten
				this._statistics.spieler[spieler.getId()].punkteAt[this._t()] = spieler.getPunkte();
				spieler.emitToController(&quot;SpielPunkte&quot;, spieler.getPunkte());
				this.emitToDisplays(&quot;SpielSpielerPunkte&quot;, spieler.getEmitData()); 
			}
		}
	}
	
	// spielerklotz und alles was damit zusammenhängt
	for(i in this._spieler){
		if(!this._spieler[i].compute()) continue;
		if(this._spieler[i].ticker()){
			this.nextFrame(this._spieler[i]);
			doesThing = true;
		}
	}
	
	if(doesThing){
		this.emitToDisplays(&quot;SpielFrame&quot;, this.getEmitData());	
	}
};

/**
 * @method calcPlatzierungen
 */
SpielAufZeit.prototype.calcPlatzierungen = function(){
	var i, j, change;
	change = false;
	// re-calc platzierungen
	var p = [];
	for(i in this._spieler){
		p.push(this._spieler[i].getPunkte());
		this._spieler[i].setPlatz(-1);
	}
	
	p.sort(function (a, b) {
		return b - a;
	});
	
	change = true; // TODO prüfen...
	
	var z = 1;
	for(j in p){
		for(i in this._spieler){
			if(this._spieler[i].getPunkte() == p[j] &amp;&amp; this._spieler[i].getPlatz() === -1){
				this._spieler[i].setPlatz(z);
				z++;
			}
		}
	}
	
	if(change){
		this.emitToDisplays(&quot;SpielPlatzierung&quot;, this.getEmitData().spieler);
	}
}

/**
  * @method nextFrame
  *
  * @param {server.Games.SpielAufZeit.Spieler} spieler
  */
SpielAufZeit.prototype.nextFrame = function(spieler){

	spieler.incrementCursorY();
	if(spieler.getCursorY() &gt; this.getH()){
		spieler.setCursorY(0);
	}
	this.computeField();
	
};

/**
  * @method computeField
  */
SpielAufZeit.prototype.computeField = function(){

	// Cursor-Blockelemente entfernen
	var x, y, i, blockelement, ownField, spieler, id, lines, out;
	
	for(y = 0; y &lt; this._h; y++){
		for(x = 0; x &lt; this._w; x++){
			if(this._field[y][x] !== null){
				if(!this._field[y][x].isSolid()){
					this._field[y][x] = null;
				}
			}
		}
	}
	
	// Cursor-Blockelemente neu setzten
	for(i in this._spieler){
		if(!this._spieler[i].compute()) continue;
		spieler = this._spieler[i];
			if(!spieler.isActive()){
			continue;
		}
		out = false;
		
		blockelement = spieler.getBlockelement();
		var calcColission = this.calcColission(spieler, blockelement)
			
		if(calcColission){
		
			// kollision vorhanden -&gt; einen hoch und solid machen
			spieler.decrementCursorY();
			var darwingPositions = this.drawOnField([spieler.getCursorX(), spieler.getCursorY()], spieler, blockelement, 1);			
			
			// wo wurde er erstellt? etwa außerhalb?
			for(i in darwingPositions){
				if(darwingPositions[i][1] == 0){
					out = true;
				}
			}
			
			// prüfe auf linie
			lines = this.checkForLine();
			
			// es gibt Punkte!
			if(lines.count&gt;0){
				spieler.addLines(1);
				
				spieler.emitToController(&quot;SpielSpielerLines&quot;, spieler.getLines());
				this.emitToDisplays(&quot;SpielSpielerLines&quot;, spieler.getEmitData());
				
				if((spieler.getLines()%CONFIG.Games.SpielAufZeit.linesForLevel)==0){
					spieler.addLevel(1);
					spieler.emitToController(&quot;SpielSpielerLevel&quot;, spieler.getLevel());
					this.emitToDisplays(&quot;SpielSpielerLevel&quot;, spieler.getEmitData());
				}
				
				if(lines.count&gt;=4){
					spieler.addPunkte(lines.count*10*2);
					this._statistics.spieler[spieler.getId()].punkteAt[this._t()] = spieler.getPunkte();
				}else{
					spieler.addPunkte(lines.count*10);
					this._statistics.spieler[spieler.getId()].punkteAt[this._t()] = spieler.getPunkte();
				}
			}
			
			// entferne die überprüften lines
			if(lines.count&gt;0){
				for(i in lines.line){
					this.removeLine(lines.line[i]);
				}
				this.emitToDisplays(&quot;SpielEffect&quot;, {type: &quot;lineKill&quot;, data: lines});
			}
			
			// punktt fürs setzten eines Steines
			spieler.addPunkte(1); // 1 Punkt, beim setzten
			this._statistics.spieler[spieler.getId()].punkteAt[this._t()] = spieler.getPunkte();
			spieler.emitToController(&quot;SpielPunkte&quot;, spieler.getPunkte());
			this.emitToDisplays(&quot;SpielSpielerPunkte&quot;, spieler.getEmitData()); 
			this.emitToDisplays(&quot;SpielEffect&quot;, {type: &quot;blockSolidate&quot;, data: null}); 
			
			if(!out){
				// neuer Stein für den Spieler, wenn der Spieler seinen Stein nicht außerhalb gesetzt hat.
				this.resetCursor(spieler);
			}else{
				// der letzte stein wurde außerhalb gesetzt. -&gt; spieler Raus
				spieler.die();
				this._statistics.spieler[spieler.getId()].died = this._t();
				this._statistics.spieler[spieler.getId()].punkte = spieler.getPunkte();
				spieler.emitToController(&quot;SpielSpielerRaus&quot;, spieler.getId());
				this.emitToDisplays(&quot;SpielSpielerRaus&quot;, spieler.getId());
				this.emitToDisplays(&quot;SpielEffect&quot;, {type: &quot;spielerRaus&quot;, data: spieler.getId()});
				
				// wenn es keinen aktiven Spieler mehr gibt, ist das Spiel zuende
				if(this.getActiveSpieler().length === 0){
					this.emitToDisplays(&quot;SpielEffect&quot;, {type: &quot;SpielEnds&quot;, data: null});
					this._statistics.gameEnds = this._t();
					
					this._game.endGame();
				}
			}
			
			//
			this.calcPlatzierungen();
			spieler.emitToController(&quot;SpielNextBlock&quot;, spieler.getNextBlockelement().getType());
		}else{
			this.drawOnField([spieler.getCursorX(), spieler.getCursorY()], spieler, blockelement, 0);
		}
	}

	// vorschau 
	for(i in this._spieler){
		if(!this._spieler[i].compute()) continue;
		spieler = this._spieler[i];
		if(!spieler.isActive()){
			continue;
		}
		blockelement = spieler.getBlockelement();
		
		x = spieler.getCursorX();
		y = spieler.getCursorY();
		
		// lauf soweit runter, bis es mal knallt, dann wieder einen hoch und 
		// vorschau setzten (falls da nichts ist, also der spielerblock selbst)
		while(!this.calcColission([x, y++], blockelement)); 
		this.drawOnField([x, y-2], spieler, blockelement, 2);
	}
};

/**
  * @method highestLine
  *
  * @return {Number|null}
  */
SpielAufZeit.prototype.highestLine = function(){
	var x, y;
	
	for(y = 0; y &lt; this._field.length; y++){
		for(x = 0; x &lt; this._field[y].length; x++){
			if(this._field[y][x] !== null &amp;&amp; this._field[y][x].isSolid()){
				return y;
			}
		}
	}
	
	return null;
};


/**
  * @method getActiveSpieler
  *
  * @return {server.Games.SpielAufZeit.Spieler}
  */
SpielAufZeit.prototype.getActiveSpieler = function(){
	var i, spieler;
	var arr = [];
	for(i in this._spieler){
		if(!this._spieler[i].compute()) continue;
		spieler = this._spieler[i];
		if(spieler.isActive()){
			arr.push(spieler);
		}
	}
	return arr;
};

/**
  * @method removeLine
  *
  * @param {Number} yToKill
  */
SpielAufZeit.prototype.removeLine = function(yToKill){
	var x,y;
	
	for(y = yToKill; y &gt; 0; y--){
		for(x = 0; x &lt; this._field[y].length; x++){
			if(y-1 &lt; 0){
				this._field[y][x] = null;
			}else{
				this._field[y][x] = this._field[y-1][x];
			}
		}
	}
};

/**
  * Prüft, welche Lines zerstört werden würden und gibt dessen Zeilennumer wieder, 
  * setzt dessen destroyed-Wert, falls dest auf true steht (optional, sonst ist dest immer true).
  *
  * @method checkForLine
  *
  * @param {Boolean} dest
  *
  * @return {Array} 
  */
SpielAufZeit.prototype.checkForLine = function(dest){
	if(dest === undefined) dest = true;
	var x,y, lines, lineOK;
	
	lines = {};
	lines.count = 0;
	lines.line = [];
	for(y = 0; y &lt; this._field.length; y++){
		lineOK = true;
		for(x = 0; x &lt; this._field[y].length &amp;&amp; lineOK; x++){
			if(this._field[y][x]===null){
				lineOK = false;
			}else{
				if(this._field[y][x].isDestroyed()){
					lineOK = false;
				}
			}
		}
		if(lineOK){
			lines.line.push(y);
			lines.count += 1;
			
			for(x = 0; x &lt; this._field[y].length; x++){
				if(dest){
					this._field[y][x].setDestroyed(true);
				}
			}
		}
	}
	
	return lines;
};


/**
  * @method resetCursor
  *
  * @param {server.Games.SpielAufZeit.Spieler} spieler
  */
SpielAufZeit.prototype.resetCursor = function(spieler){
	spieler.setCursorY(0);
	spieler.nextElement();
	var center_x = this.getW()/2;
	
	// wenn der gegen eine wand geraten ist, verschiebe ihn richtung mitte, bis es nicht mehr der fall ist
	 // nur den ersten prüfen.. genügt.
	while(this.calcColission([spieler.getCursorX(),spieler.getCursorY()], spieler.getBlockelement())[0]==2){
		spieler.setCursorX(spieler.getCursorX()+(spieler.getCursorX() &lt; center_x ? 1 : -1));
	};

	this.drawOnField([spieler.getCursorX(),spieler.getCursorY()],spieler, spieler.getBlockelement(), 0);
};

/**
  * @method isXOut
  *
  * @param {Number} x 
  *
  * @return {Boolean}
  */
SpielAufZeit.prototype.isXOut = function(x){
	return (x&lt;0) || (x&gt;=this.getW());
};

/** 
 * @method calcColission
 *
 * @param {server.Games.SpielAufZeit.Spieler|Array} spielerOrPosition
 * @param {server.Games.SpielAufZeit.Blockelement} blockelement
 *
 * @return {false|Number} 1 = gegen ein anderen Block, 2 = außerhalb des Spielfeldes, 3 = unten auf den Boden
 */
SpielAufZeit.prototype.calcColission = function(spielerOrPosition, blockelement){

	var offsetY, offsetX, ownField,x,y,element;
	ownField = blockelement.getOwnField();

	if(spielerOrPosition instanceof Spieler){
		offsetX = spielerOrPosition.getCursorX();
		offsetY = spielerOrPosition.getCursorY();
	}else{
		offsetX = spielerOrPosition[0];
		offsetY = spielerOrPosition[1];
	}
	
	for(y = 0; y &lt; ownField.length; y++){
		for(x = 0; x &lt; ownField[y].length; x++){
			if(ownField[y][x] === 0){continue;}
			
			if(this._field.length &lt;= (y+offsetY)){
				return [3, y+offsetY];  // unten auf den Boden 
			}
			
			if(this.isXOut(x+offsetX)){
				return [2, y+offsetY]; // außerhalb des Spielfeldes
			}
			
			if(y+offsetY &lt; 0){
				return [4, y+offsetY]; // oben
			}
			
			// mit anderen elementen
			element = this._field[y+offsetY][x+offsetX];
			if(element !== null &amp;&amp; element.isSolid()){
				return [1, y+offsetY]; // gegen ein anderen Block
			}
		}	
	}
	
	return false;
};

/**
 * 
 * @method drawOnField
 *
 * @param {Array} xy
 * @param {server.Games.SpielAufZeit.Spieler} spieler
 * @param {server.Games.SpielAufZeit.Blockelement} blockelement
 * @param {Number} typ typ=0: spielerblock, typ=1: solid, typ=2: vorschau
 *
 * @return {Array} positionen, inden gezeichnet wurde
 */
SpielAufZeit.prototype.drawOnField = function(xy, spieler, blockelement, typ){
	var offsetY, offsetX,x,y,id, ownField;
	var darwingPositions = [];
	
	id = spieler.getId();

	offsetX = xy[0];
	offsetY = xy[1];
	
	ownField = blockelement.getOwnField();
	
	for(y = 0; y &lt; ownField.length; y++){
		for(x = 0; x &lt; ownField[y].length; x++){
		
			if(ownField[y][x] === 0){continue;}
			
			if((y+offsetY)&lt;0){
				continue;
			}
			if((x+offsetX)&lt;0){
				continue;
			}
			
			if(this._field.length &lt;= (y+offsetY)){ 
				continue; 
			}
			if(this._field[y+offsetY].length &lt;= (x+offsetX)){
				continue;
			}
			
			if(typ===2){
				// vorschau
				if(this._field[y+offsetY][x+offsetX] === null){
					this._field[y+offsetY][x+offsetX] = new Block(spieler);
					this._field[y+offsetY][x+offsetX].setVorschau(true);
				}
			}
			
			if(typ===1){
				 // solid
				this._field[y+offsetY][x+offsetX] = new Block(spieler);
				this._field[y+offsetY][x+offsetX].setSolid(true);			
			}
			
			if(typ===0){
				// spielerblock
				this._field[y+offsetY][x+offsetX] = new Block(spieler);
			}
			
			darwingPositions.push([x+offsetX,y+offsetY]);
		}	
	}
	
	return darwingPositions;
};

/**
 * @method buttonLeftDown
 * @param {server.Games.SpielAufZeit.Spieler} spieler
 */
SpielAufZeit.prototype.buttonLeftDown = function(spieler){
	if(!this.calcColission([spieler.getCursorX()-1,spieler.getCursorY()], spieler.getBlockelement())){
		spieler.decrementCursorX();
		
		if(spieler._goLeftInterval){
			clearInterval(spieler._goLeftInterval);	
		}
		spieler._goLeftIntervalStart = CONFIG.Games.SpielAufZeit.buttonDownWaitIntervals;
		spieler._goLeftInterval = setInterval(function(){
			if(spieler._goLeftIntervalStart&gt;0){
				spieler._goLeftIntervalStart--;
				return;
			}
			
			if(!this.calcColission([spieler.getCursorX()-1,spieler.getCursorY()], spieler.getBlockelement())){
				spieler.decrementCursorX();
				
				this.computeField();
				this.emitToDisplays(&quot;SpielFrame&quot;, this.getEmitData());
			}
		}.bind(this), CONFIG.Games.SpielAufZeit.buttonDownIntervalTime);
	}
};

/**
 * @method buttonLeftUp
 * @param {server.Games.SpielAufZeit.Spieler} spieler
 */
SpielAufZeit.prototype.buttonLeftUp = function(spieler){
	if(spieler._goLeftInterval){
		clearInterval(spieler._goLeftInterval);	
	}
};

/**
 * @method buttonRightDown
 * @param {server.Games.SpielAufZeit.Spieler} spieler
 */
SpielAufZeit.prototype.buttonRightDown = function(spieler){
	if(!this.calcColission([spieler.getCursorX()+1,spieler.getCursorY()], spieler.getBlockelement())){
		spieler.incrementCursorX();
		
		
		if(spieler._goRightInterval){
			clearInterval(spieler._goRightInterval);	
		}
		spieler._goRightIntervalStart = CONFIG.Games.SpielAufZeit.buttonDownWaitIntervals;
		spieler._goRightInterval = setInterval(function(){
			if(spieler._goRightIntervalStart&gt;0){
				spieler._goRightIntervalStart--;
				return;
			}
			
			if(!this.calcColission([spieler.getCursorX()+1,spieler.getCursorY()], spieler.getBlockelement())){
				spieler.incrementCursorX();
				
				this.computeField();
				this.emitToDisplays(&quot;SpielFrame&quot;, this.getEmitData());
			}
		}.bind(this), CONFIG.Games.SpielAufZeit.buttonDownIntervalTime);
	}
};

/**
 * @method buttonRightUp
 * @param {server.Games.SpielAufZeit.Spieler} spieler
 */
SpielAufZeit.prototype.buttonRightUp = function(spieler){
	if(spieler._goRightInterval){
		clearInterval(spieler._goRightInterval);	
	}
};

/**
 * @method buttonDownDown
 * @param {server.Games.SpielAufZeit.Spieler} spieler
 */
SpielAufZeit.prototype.buttonDownDown = function(spieler){
	while(!this.calcColission(spieler, spieler.getBlockelement())){
		spieler.incrementCursorY();
	}
	spieler.decrementCursorY();
	this.nextFrame(spieler);
	spieler.ticker(spieler.getTickTime(), true);
};

/**
 * @method buttonRotateLeftDown
 * @param {server.Games.SpielAufZeit.Spieler} spieler
 */
SpielAufZeit.prototype.buttonRotateLeftDown = function(spieler){
	spieler.getBlockelement().rotateLeft();
	var collisionValue = this.calcColission([spieler.getCursorX(),spieler.getCursorY()], spieler.getBlockelement());
	if(collisionValue[0]==2){
		// wenn der gegen eine wand geraten ist, verschiebe ihn richtung mitte, bis es nicht mehr der fall ist
		
		do{
			var center_x = this.getW()/2;
			if(spieler.getCursorX() &lt; center_x){
				spieler.setCursorX(spieler.getCursorX()+1);
			}else{
				spieler.setCursorX(spieler.getCursorX()-1);
			}
			collisionValue = this.calcColission([spieler.getCursorX(),spieler.getCursorY()], spieler.getBlockelement());
		}while(collisionValue[0]==2);
	
		
	}else if(collisionValue){
		spieler.getBlockelement().rotateRight();
	}
	
	this.emitToDisplays(&quot;SpielEffect&quot;, {type: &quot;blockRotate&quot;, data: null});
};

/**
 * @method buttonRotateRightDown
 * @param {server.Games.SpielAufZeit.Spieler} spieler
 */
SpielAufZeit.prototype.buttonRotateRightDown = function(spieler){
	spieler.getBlockelement().rotateRight();
	var collisionValue = this.calcColission([spieler.getCursorX(),spieler.getCursorY()], spieler.getBlockelement());
	if(collisionValue[0]==2){
		// wenn der gegen eine wand geraten ist, verschiebe ihn richtung mitte, bis es nicht mehr der fall ist
		
		do{
			var center_x = this.getW()/2;
			if(spieler.getCursorX() &lt; center_x){
				spieler.setCursorX(spieler.getCursorX()+1);
			}else{
				spieler.setCursorX(spieler.getCursorX()-1);
			}
			collisionValue = this.calcColission([spieler.getCursorX(),spieler.getCursorY()], spieler.getBlockelement());
		}while(collisionValue[0]==2);
	
	
	}else if(collisionValue){
		spieler.getBlockelement().rotateLeft();	
	}
	
	this.emitToDisplays(&quot;SpielEffect&quot;, {type: &quot;blockRotate&quot;, data: null});
};

/**
 * @method button
 *
 * @param {BUTTONTYPE} type
 * @param {BUTTON} key
 * @param {Profil} profil
 */
SpielAufZeit.prototype.button = /*overwride*/ function(type, key, profil){

	var i, spieler = null;
	var recalc = false;
	
	for(i in this._spieler){
		if(!this._spieler[i].compute()) continue;
		if(this._spieler[i].getId() == profil.ProfilID){
			spieler = this._spieler[i];
			break;
		}
	}

	if(spieler === null){
		// do nothing... 
		return;
	}
	
	if(key === BUTTON.Left &amp;&amp; type === BUTTONTYPE.Down){
		this.buttonLeftDown(spieler);
		recalc = true;
	}
	
	if(key === BUTTON.Right &amp;&amp; type === BUTTONTYPE.Down){
		this.buttonRightDown(spieler);
		recalc = true;
	}
	
	if(key === BUTTON.Left &amp;&amp; type === BUTTONTYPE.Up){
		this.buttonLeftUp(spieler);
		recalc = true;
	}
	
	if(key === BUTTON.Right &amp;&amp; type === BUTTONTYPE.Up){
		this.buttonRightUp(spieler);
		recalc = true;
	}
	
	if(key === BUTTON.RotateLeft &amp;&amp; type === BUTTONTYPE.Down){
		this.buttonRotateLeftDown(spieler);
		recalc = true;
	}
	
	if(key === BUTTON.RotateRight &amp;&amp; type === BUTTONTYPE.Down){
		this.buttonRotateRightDown(spieler);
		recalc = true;
	}
	
	if(key === BUTTON.Down &amp;&amp; type === BUTTONTYPE.Down){
		this.buttonDownDown(spieler);
		recalc = true;
	}
	
	// nach einer gültigen benutzereingabe immer ein frame schicken
	if(recalc){
		this._statistics.spieler[spieler.getId()].buttonAt[this._t()] = [key,type];
		this.computeField();
		this.emitToDisplays(&quot;SpielFrame&quot;, this.getEmitData());
	}
};

/**
 * @method getEmitData
 *
 * @return JSON
 */
SpielAufZeit.prototype.getEmitData = function(){
	var r = {}, cursor, spieler, i, x,y,row;
	r.w = this._w;
	r.h = this._h;
	
	r.spieler = [];
	for(i in this._spieler){
		r.spieler.push(this._spieler[i].getEmitData());
	}
	
	r.field = [];
	for(y = 0; y &lt; this._h; y++){
		row = [];
		for(x = 0; x &lt; this._w; x++){
			if(this._field[y][x] === null){
				row.push(null);
			}else{
				row.push(this._field[y][x].getEmitData());
			}
		}
		r.field.push(row);
	}
	
	return r;
};

exports.SpielAufZeit = SpielAufZeit;
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
